#! /opt/rocks/usr/bin/python
#
# Script to generate the Condor configuration files.
#
# @Copyright@
# 
# 				Rocks(r)
# 		         www.rocksclusters.org
# 		         version 5.4 (Maverick)
# 
# Copyright (c) 2000 - 2010 The Regents of the University of California.
# All rights reserved.	
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright
# notice unmodified and in its entirety, this list of conditions and the
# following disclaimer in the documentation and/or other materials provided 
# with the distribution.
# 
# 3. All advertising and press materials, printed or electronic, mentioning
# features or use of this software must display the following acknowledgement: 
# 
# 	"This product includes software developed by the Rocks(r)
# 	Cluster Group at the San Diego Supercomputer Center at the
# 	University of California, San Diego and its contributors."
# 
# 4. Except as permitted for the purposes of acknowledgment in paragraph 3,
# neither the name or logo of this software nor the names of its
# authors may be used to endorse or promote products derived from this
# software without specific prior written permission.  The name of the
# software includes the following terms, and any derivatives thereof:
# "Rocks", "Rocks Clusters", and "Avalanche Installer".  For licensing of 
# the associated name, interested parties should contact Technology 
# Transfer & Intellectual Property Services, University of California, 
# San Diego, 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910, 
# Ph: (858) 534-5815, FAX: (858) 534-7345, E-MAIL:invent@ucsd.edu
# 
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# @Copyright@
#
# $Log: CondorConf,v $
# Revision 1.28  2010/09/07 23:53:12  bruno
# star power for gb
#
# Revision 1.27  2009/12/08 00:42:43  phil
# New version of Condor
#
# Revision 1.26  2009/05/01 19:07:14  mjk
# chimi con queso
#
# Revision 1.25  2008/10/18 00:56:06  mjk
# copyright 5.1
#
# Revision 1.24  2008/03/06 23:41:49  mjk
# copyright storm on
#
# Revision 1.23  2007/07/14 02:28:15  phil
# Open up HOSTALLOW_WRITE just a bit
#
# Revision 1.22  2007/06/23 04:03:32  mjk
# mars hill copyright
#
# Revision 1.21  2007/06/11 20:58:24  phil
# Move condor volatile files (execute/log/spool) to /var/opt/condor
# condor config localization in /opt/condor
#
# Revision 1.20  2006/09/11 22:47:55  mjk
# monkey face copyright
#
# Revision 1.19  2006/08/10 00:10:12  mjk
# 4.2 copyright
#
# Revision 1.18  2006/07/31 18:26:11  phil
# HOSTALLOW_WRITE should be "<masterhost>, *.<localdomain>"
#
# Revision 1.17  2006/07/27 21:17:13  phil
# Add HOSTALLOW_WRITE directive to CondorConf (needed for Condor 6.8.0)
# Use condor reserved ID
#
# Revision 1.16  2006/03/25 16:04:29  phil
# Moving to version 6.7.14
#
# Revision 1.15  2006/01/16 06:49:02  mjk
# fix python path for source built foundation python
#
# Revision 1.14  2005/11/24 01:29:30  nadya
# add job runnign policy
#
# Revision 1.13  2005/11/23 01:58:18  nadya
# use central manager for dedicated scheduler
#
# Revision 1.12  2005/11/21 23:32:27  nadya
# fix syntax
#
# Revision 1.11  2005/11/07 23:14:55  nadya
# use rocks' python
#
# Revision 1.10  2005/10/30 01:45:38  nadya
# add new variables for MPI universe handling
#
# Revision 1.9  2005/10/12 18:08:57  mjk
# final copyright for 4.1
#
# Revision 1.8  2005/09/16 01:02:32  mjk
# updated copyright
#
# Revision 1.7  2005/06/15 18:37:07  nadya
# rm temp output code
#
# Revision 1.6  2005/06/15 05:19:24  nadya
# add EMAIL_DOMAIN defined to be the fqdn of a submitting host.
# should help avoid problems mail when users don't specify 'notify_user'
# in the submit scripts
#
# Revision 1.5  2005/06/15 01:09:41  nadya
# change command line arguments to allow for separation of pool machine functionalities
# update help()
# add mpi configuration (dedicated resource)
#
# Revision 1.4  2005/05/24 21:22:07  mjk
# update copyright, release is not any closer
#
# Revision 1.3  2005/05/12 02:03:29  nadya
# change arguments to allow choice of interfaces (picked from the "manager" argument.
# add vavriables to disable sending messages to central condor at wisconsin
# add better usage()
#
# Revision 1.2  2005/05/04 17:36:09  nadya
# add arg checking and verification, extend usage()
#
# Revision 1.2  2004/10/04 23:28:58  nadya
# add daemons and run time dirs
#
# Revision 1.1  2004/07/12 23:52:48  nadya
# condor configuration script
#
#

import sys
import os
import socket
import pwd
import string
import types
import rocks.app
import rocks.net


class Conf(rocks.app.Application):
	def __init__(self, argv):
		rocks.app.Application.__init__(self, argv)
		self.NetApp = rocks.net.Application(argv)
		self.getopt.s = ['h']
		self.getopt.l = ['help']
		self.getopt.s.extend([('t:', 'type'),
                                      ('m:', 'central-manager'),
                                      ('n:', 'node'),
                                      ('d' ),
                                      ])
		self.getopt.l.extend([('type=', 'type'),
                                      ('manager=', 'central-manager'),
                                      ('node=', 'node'),
                                      ('localdomain=', 'local domain'),
                                      ('dedicated'),
                                      ])

		self.usage_version = '1.0'
		self.abspath = os.path.realpath(argv[0])
		self.type = None
		self.node = None
		self.cm = None
		self.localDomain = None
		self.dedicated = None
		self.parseArgs()
		self.checkArgs()


	def usage(self):
		self.SPACE = '        '
		self.printName()
		self.printSynopsis()
		self.printDescription()

	def printName(self):
		print \
		'\nNAME\n',\
		self.SPACE + self.usage_command,\
		' - creates condor configuration files, version ' + self.usage_version

	def printDescription(self):
		print \
		'\nDESCRIPTION\n',\
		self.SPACE + self.usage_command,\
		'creates two configuraton files on either a frontend or a compute\n',\
		self.SPACE + 'node. The generic configuraton file is $CONDOR_ROOT/etc/condor_config,\n',\
		self.SPACE + 'and the local configuration file is $CONDOR_ROOT/etc/condor_config.local\n',\
		self.SPACE + 'In general, the frontend should be a pool\'s central manager, with an\n',\
		self.SPACE + 'additional capability of a submit machine. The compute nodes are usually\n',\
		self.SPACE + 'execute and submit machines.\n\n',\
		self.SPACE + 'Options  in [] can be  omitted;  in this case  defaults created  during\n',\
		self.SPACE + 'installation  are used.  The rest of  the options are required.\n\n',\
		self.SPACE + 'The following options are supported by',self.usage_command,':\n\n',\
		self.SPACE + '-h | --help \n',\
		self.SPACE + self.SPACE + 'Prints usage message on stdout.\n',\
		self.SPACE + '-n NODE | --node=NODE \n',\
		self.SPACE + self.SPACE + 'Set class of a node. Valid values: frontend, compute.\n',\
		self.SPACE + '-t TYPES | --type=TYPES \n',\
		self.SPACE + self.SPACE + 'Set type of a node. TYPES is a concatenation of the first\n',\
		self.SPACE + self.SPACE + 'letters (in any order) of the node function in the condor pool:\n',\
		self.SPACE + self.SPACE + 's - for submit machine \n',\
		self.SPACE + self.SPACE + 'e - for execute machine \n',\
		self.SPACE + self.SPACE + 'm - for central manager machine \n',\
		self.SPACE + '-m HOST | --manager=HOST\n',\
		self.SPACE + self.SPACE + 'Set condor\'s central manager to the HOST, where HOST\n',\
		self.SPACE + self.SPACE + 'can be either IP or FQDN.\n',\
		self.SPACE + '-d | --dedicated\n',\
		self.SPACE + self.SPACE + 'Configure as dedicated resource for running MPI jobs \n',\


	def printSynopsis(self):
		print '\nSYNOPSIS'
		# short options 
		self.slist = [self.usage_command]
		for e in self.getopt.s:
			if type(e) == types.TupleType:
				self.slist.append(' -%s %s' % ( e[0][:-1], e[1]))
			else:
				self.slist.append(' [-%s]' % e)
		self.printCommand(self.slist)

		# long options
		self.llist = [self.usage_command]
		for e in self.getopt.l:
			if type(e) == types.TupleType:
				self.llist.append(' --%s=%s' % (e[0][:-1],e[1]))
			else:
				self.llist.append(' [--%s]' % e)
		self.printCommand(self.llist)


	def printCommand(self, list):
		if os.environ.has_key('COLUMNS'):
			cols = os.environ['COLUMNS']
		else:
			cols = 80

		s = self.SPACE
		l = len(self.SPACE)
		for e in list:
			if l + len(e) < cols:
				s = s + e + ' '
				l = l + 1 + len(e)
			else:
				print s
				s = self.SPACE + ' ' * (len(self.usage_command)+1) + e + ' '
				l = len(s)
		if s:
			print s



	def parseArg(self, c):
		if rocks.app.Application.parseArg(self,c):
			return 1
		elif c[0] in ('-t', '--type'):
			self.type = c[1]
			if self.type[0] == '=': 
				print '\nERROR: wrong syntax for argument type'
				print '\nUse %s -h for more info' % self.usage_command
				sys.exit(-1)
		elif c[0] in ('-n', '--node'):
			self.node = c[1]
			if self.node[0] == '=': 
				print '\nERROR: wrong syntax for argument node'
				print '\nUse %s -h for more info' % self.usage_command
				sys.exit(-1)
		elif c[0]  in ('-m', '--manager') :
			self.cm = c[1]
			if self.cm[0] == '=': 
				print '\nERROR: wrong syntax for argument manager'
				print '\nUse %s -h for more info' % self.usage_command
				sys.exit(-1)
		elif c[0] in ('--localdomain'):
			self.localDomain = c[1]
			if self.localDomain[0] == '=': 
				print '\nERROR: wrong syntax for argument localDomain'
				print '\nUse %s -h for more info' % self.usage_command
				sys.exit(-1)
		elif c[0]  in ('-d', '--dedicated') :
			self.dedicated = 1
		else:
			return 0
	
		return 1


	def checkArgs(self):
		helpline = 'Use %s -h for more info\n' % self.usage_command
		error = 0
		if not self.cm:
			print 'ERROR: missing argument manager'
			error = 1

		if not self.type:
			print 'ERROR: missing argument type'
			error = 1

		if not self.node:
			print 'ERROR: missing argument node'
			error = 1

		# check nodes validity
		nodes = ['frontend', 'compute']
		if self.node not in nodes :
			print 'ERROR: illegal node', self.node
			error = 1
		if error:
			print helpline
			sys.exit(-1)

		# check types validity
		# s - submit, e - execute, m - pool manager
		types = 'sem'
		for i in self.type:
			if i not in types :
				print 'ERROR: illegal type', i
				error = 1
		if error:
			print helpline
			sys.exit(-1)


	def setNetworkParams(self):
		""" find public/private hostname, domain name """
		try:
			cm_hostNames = socket.gethostbyaddr(self.cm)
		except (socket.gaierror, socket.herror), e:
			print e[1], '(%s)' % self.cm
			sys.exit(-1)

		# find info about cenrtal manager
		self.cm_fqdn = cm_hostNames[0]
		self.cm_domainName = self.cm_fqdn[string.find(self.cm_fqdn, '.')+1:]

		#find info about local host
		self.privateInterface = self.NetApp.privateIP()
		hostNames = socket.gethostbyaddr(socket.gethostname())
		self.host = hostNames[0][:string.find(hostNames[0], '.')]
		self.host_fqdn = hostNames[0]
		if cm_hostNames[2][0] == self.privateInterface:
			self.ip = self.privateInterface
		else:
			self.ip = hostNames[2][0]


	def setDefaults(self):
		""" set condor location and config files """
		self.user = 'condor'
		index = string.find(self.abspath, '/sbin')
		if index < 0 :
			self.releaseDir = '.'
		else:
			self.releaseDir = self.abspath[:index]
		self.configMain = self.releaseDir + '/etc/condor_config'
		self.configLocal = self.releaseDir + '/etc/condor_config.local' 
		self.confTemplate = self.releaseDir + '/etc/examples/condor_config.generic'
		self.getUID()


	def makeConfDir(self, dir, mod=0755):
		""" create local config directory """
		if os.path.isdir(dir):
			return
		try:
			os.mkdir(dir, mod)
		except OSError:
			print 'Cannot create directory', dir
			sys.exit(-1)


	def makeRunDirs(self):
		""" Create run time direcotries """
		names = ['/log', '/spool', '/execute']
		for name in names:
			self.makeConfDir(self.localDir + name)
			os.chown(self.localDir + name, self.uid, self.gid)

		command = 'chmod 1777 %s' % self.localDir + '/execute'
		os.system(command)


	def writefile(self, name, lines):
		""" write config file """
		text = string.join(lines, '')
		try:
			f = open(name, 'w')
			f.write (text)
			f.close()
		except IOError:
			print 'Error writing config file %s' % name
			sys.exit(-1)
	

	def readfile(self, name):
		""" read confgiuration template file """
		try:
			f = open(name, 'r')
			lines = f.readlines()
			f.close()
		except IOError:
			print 'File %s does not exist or is not readable' % name
			sys.exit(-1)
	
		return lines


	def findString(self, lines, str, value):
		""" find a string to be swapped in a config file """
		count = 0
		for text in lines:
			a = string.find(text, str, 0)
			if a == 0 :
				if value == None:
					newtext = '#' + text
				else:
					newtext = str + ' = ' + value + '\n'
				lines[count] = newtext
			count  =  count + 1

	
	def makeConfigGeneric(self): 
		""" create main config file """
		dict = {}
		dict['LOCAL_CONFIG_FILE'] = self.configLocal
		dict['CONDOR_HOST'] = None
	
		# get generic template and make substitutions
		lines = self.readfile(self.confTemplate)
		for key, value in dict.items():
			self.findString(lines, key, value)

		header = ['#\n#  Condor main configuration file for %s node.\n#\n' % self.node]
		self.writefile(self.configMain, header + lines)


	def getUID(self):
		""" finds condor's uid and gid """
		try:
			info = pwd.getpwnam(self.user)
		except KeyError:
			print 'User %s does not exist\n' % self.user
			sys.exit(-1)

		self.uid = info[2]
		self.gid = info[3]


	def find_executable(self, executable, path=None):
		""" find a path to the executable """
		if os.path.isfile(executable):
			return executable

		if path is None:
			path = os.environ['PATH']
		paths = string.split(path, os.pathsep)
	
		for path in paths:
			fullname = os.path.join(path, executable)
			if os.path.isfile(fullname):
				return fullname
		return ''
	

	def setDaemons(self): 
		# set known daemons
		types = {
			's':'SCHEDD',                   # submit machine
			'e':'STARTD',                   # execute machine
			'm':'COLLECTOR, NEGOTIATOR'     # pool central manager
			}

		daemons = 'MASTER'			# main daemon, always present 
		for i in self.type:
			daemons = daemons + ', ' + types[i]

		return daemons

	def setDedicated(self, dict): 
		if not self.dedicated:
			return

		dict['DedicatedScheduler']  = '"DedicatedScheduler@%s"' % self.cm_fqdn
		dict['MPI_CONDOR_RSH_PATH'] = '$(LIBEXEC)'
		dict['STARTD_EXPRS']        = '$(STARTD_EXPRS), DedicatedScheduler'
		dict['CONDOR_SSHD'] = '/usr/sbin/sshd'
		dict['CONDOR_SSH_KEYGEN'] = '/usr/bin/ssh-keygen'
		self.setPolicy2(dict)


	def setPolicy1(self, dict): 
		# settings for policy 'only allow dedicated jobs'
		dict['START']        = 'True'
		dict['SUSPEND']      = 'False'
		dict['CONTINUE']     = 'True'
		dict['PREEMPT']      = 'False'
		dict['KILL']         = 'False'
		dict['WANT_SUSPEND'] = 'False'
		dict['WANT_VACATE']  = 'False'
		dict['RANK']         = 'Scheduler =?= $(DedicatedScheduler)'


	def setPolicy2(self, dict): 
		# settings for policy 'always run jobs but prefer dedicated ones'
		dict['START']        = 'True'


	def makeConfigLocal(self): 
		""" create a local config file """
		dict = {}
		dict['CONDOR_DEVELOPERS']           = 'NONE'
		dict['CONDOR_DEVELOPERS_COLLECTOR'] = 'NONE'
		dict['NEGOTIATOR_INTERVAL']         = '120'
		dict['LOCK']                        = '/tmp/condor-lock.$(HOSTNAME)'
		dict['RELEASE_DIR']                 = '/opt/condor'
		dict['LOCAL_DIR']                   = '/var/opt/condor'
		dict['FILESYSTEM_DOMAIN']           = self.cm_domainName
		dict['UID_DOMAIN']                  = self.cm_domainName
		dict['EMAIL_DOMAIN']                = '$(FULL_HOSTNAME)'
		dict['RELEASE_DIR']                 = self.releaseDir
		dict['CONDOR_IDS']                  = '%s.%s' % (self.uid, self.gid)
		dict['MAIL']                        = self.find_executable('mail')
		dict['JAVA']                        = self.find_executable('java')
		dict['NETWORK_INTERFACE']           = self.ip
		dict['CONDOR_ADMIN']                = 'condor@%s' % self.cm_fqdn
		dict['CONDOR_HOST']                 = self.cm_fqdn
		if self.localDomain == None:
			dict['HOSTALLOW_WRITE'] = self.cm_fqdn
		else:
			dict['HOSTALLOW_WRITE'] = '%s, *.%s, *.%s' % (self.cm_fqdn,self.localDomain,dict['UID_DOMAIN'])

		dict['ALLOW_WRITE'] = dict['HOSTALLOW_WRITE'] 
		self.localDir = dict['LOCAL_DIR']
		if self.node == 'frontend':
			dict['COLLECTOR_NAME'] = 'Collector at %s' % self.host

		dict['DAEMON_LIST'] = self.setDaemons()
		self.setDedicated(dict)

		keys = dict.keys()
		keys.sort()
		lines = []
		for key in keys:
			lines.append('%s = %s\n' % (key, dict[key]))

		header = ['#\n#  Condor local configuration file for %s node.\n#\n' % self.node]
		self.writefile(self.configLocal, header + lines)


	def Config(self):
		""" configuration driver """
		self.setNetworkParams()
		self.setDefaults()
		self.makeConfigGeneric()
		self.makeConfigLocal()
		self.makeRunDirs()


app = Conf(sys.argv)
app.Config()


